#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 5.4
#  in conjunction with Tcl version 8.6
#    Aug 11, 2020 01:35:24 PM EAT  platform: Linux

import sys

import tkinter as tk
import tkinter.ttk as ttk

import serial
import tk_plot_support
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from threading import Timer
from datetime import datetime

def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    top = FreqPlot (root)
    tk_plot_support.init(root, top)
    root.mainloop()

w = None
def create_FreqPlot(rt, *args, **kwargs):
    '''Starting point when module is imported by another module.
       Correct form of call: 'create_FreqPlot(root, *args, **kwargs)' .'''
    global w, w_win, root
    #rt = root
    root = rt
    w = tk.Toplevel (root)
    top = FreqPlot (w)
    tk_plot_support.init(w, top, *args, **kwargs)
    return (w, top)

def destroy_FreqPlot():
    global w
    w.destroy()
    w = None

class FreqPlot:
    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85'
        _ana2color = '#ececec' # Closest X11 color: 'gray92'
        font10 = "-family {DejaVu Sans} -size 24 -weight bold"
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.',background=_bgcolor)
        self.style.configure('.',foreground=_fgcolor)
        self.style.configure('.',font="TkDefaultFont")
        self.style.map('.',background=
            [('selected', _compcolor), ('active',_ana2color)])

        top.geometry("600x450+651+175")
        top.minsize(1, 1)
        top.maxsize(1905, 1050)
        top.resizable(1, 1)
        top.title("Plotter")
        top.configure(background="#d9d9d9")

        self.dim = 0
        self.xs = []
        for i in range(93, 2000, 31):
            self.xs.append(i)

        self.record = True
        self.recorded_samples = 0
        self.cycle_timer = Timer(1.0, self.take_readings)

        # self.ys = [610,240,199,37,79,72,24,15,9,21,5,7,14,7,10,5,11,2,2,8,2,3,
        # 0,3,2,3,4,2,2,3,1,5,4,4,1,4,2,0,1,4,3,1,3,2,0,2,2,2,3,4,0,3,1,2,1,0,1,2,1,3,1,1]

        self.fig = plt.figure()
        self.ax1 = self.fig.add_subplot(1, 1, 1)
        self.canvas = FigureCanvasTkAgg(self.fig, master=top)

        self.canvas.draw()
        self.canvas.get_tk_widget().place(relx=0.01, rely=0.067, relheight=0.85, relwidth=0.95)

        toolbar = NavigationToolbar2Tk(self.canvas, top)
        toolbar.update()
        self.canvas.get_tk_widget().place(relx=0.01, rely=0.067, relheight=0.85, relwidth=0.95)

        self.TempFrame = ttk.Frame(top)
        self.TempFrame.place(relx=0.683, rely=0.022, relheight=0.278
                , relwidth=0.208)
        self.TempFrame.configure(relief='groove')
        self.TempFrame.configure(borderwidth="2")
        self.TempFrame.configure(relief="groove")

        self.TempLabel = ttk.Label(self.TempFrame)
        self.TempLabel.place(relx=0.054, rely=0.08, height=17, width=97)
        self.TempLabel.configure(background="#d9d9d9")
        self.TempLabel.configure(foreground="#000000")
        self.TempLabel.configure(font="TkDefaultFont")
        self.TempLabel.configure(relief="flat")
        self.TempLabel.configure(anchor='e')
        self.TempLabel.configure(justify='left')
        self.TempLabel.configure(text='''Temperature:''')

        self.TempValLabel = ttk.Label(self.TempFrame)
        self.TempValLabel.place(relx=0.054, rely=0.24, height=77, width=127)
        self.TempValLabel.configure(background="#d9d9d9")
        self.TempValLabel.configure(foreground="#21af2f")
        self.TempValLabel.configure(font=font10)
        self.TempValLabel.configure(relief="flat")
        self.TempValLabel.configure(anchor='w')
        self.TempValLabel.configure(justify='left')
        self.TempValLabel.configure(text='''0.00''')

        # self.ax1.clear()
        # self.ax1.bar(self.xs, self.ys, width=20)

        self.ani = animation.FuncAnimation(self.fig, self.animate, repeat_delay=10)


    def take_readings(self):
        # unblocking function
        self.cycle_timer.cancel()
        print("============= UNBLOCK RECORDING ==============")
        self.record = True


    def read_serial_data(self):
        start = False
        ser_str = ""
        while True:
            available = tk_plot_support.ser_port.in_waiting
            if (available > 0):
                # print("available ", available)
                for i in range(available):
                    byte_ch = tk_plot_support.ser_port.read(1)
                    try:
                        ch = byte_ch.decode('utf-8')
                    except UnicodeDecodeError:
                        continue
                
                    if (start == False):
                        if (ch == '\n'):
                            start = True
                    else:
                        if (ch == '\n'):
                            # print("String: ", ser_str, " len ", len(ser_str))
                            ser_str += '\n'
                            return ser_str
                        else:
                            ser_str += ch


    def pack_data_to_dict(self):
        frequencies = {}
        num = ""
        str_data = ""
        try:
            str_data = self.read_serial_data()
        except OSError:
            tk_plot_support.ser_port.close()
            self.__del__()
        print("Serial string: ", str_data)
        count = 0
        for i in range(len(str_data)):
            try:
                if (str_data[i] == ','):
                    frequencies[count] = int(num)
                    count += 1
                    num = ""
                    continue
                elif (str_data[i] == '\n'):
                    frequencies[count] = int(num)
                else:
                    num += str_data[i]
            except ValueError:
                continue

        if (count == 64):
            return frequencies
        else:
            return None


    def write_to_csv(self, data):
        delimiter = ","
        currentDT = datetime.now()
        date_str = currentDT.strftime("%d/%m/%Y")
        time_str = currentDT.strftime("%H:%M:%S")
        data_str = [str(i) for i in data]
        with open(tk_plot_support.file_path, "a") as file_stream:
            file_stream.write(date_str + "," + time_str + ",")
            file_stream.write(delimiter.join(data_str) + "\n")

    def animate(self, i):
        graph_data = self.pack_data_to_dict()
        print(graph_data)

        currentDT = datetime.now()
        time_str = currentDT.strftime("%H:%M:%S:%f")
        print(time_str)

        if (graph_data != None):
            del graph_data[0]
            del graph_data[1]

            temp = graph_data[64]
            self.TempValLabel.configure(text=str(temp))
            del graph_data[64]

            ys = list(graph_data.values())
            # print("xs:", len(xs), "ys:", len(ys))

            self.ax1.clear()
            self.ax1.set_ylim(bottom = 0, top = 500, auto = False)
            self.ax1.bar(self.xs, ys, width = 20)

            if (self.record == True):
                if (self.dim == tk_plot_support.sample_interval):
                    self.dim = 0
                    print("Saving...")
                    self.write_to_csv(ys)
                    self.recorded_samples += 1
                    if (self.recorded_samples == tk_plot_support.no_samples):
                        self.recorded_samples = 0
                        self.record = False
                        self.cycle_timer = Timer(float(tk_plot_support.cycle_time), self.take_readings)
                        self.cycle_timer.start()

                self.dim+=1


if __name__ == '__main__':
    vp_start_gui()





